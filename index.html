<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jigsaw 9.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              mono: ['Roboto Mono', 'monospace'],
            },
          },
        },
      }
    </script>
    <style>
      @keyframes gradient {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      body {
        background-color: #020617; /* slate-900 */
        background-image: radial-gradient(at 27% 37%, hsla(215, 98%, 42%, 0.1) 0px, transparent 50%), 
                          radial-gradient(at 97% 21%, hsla(125, 98%, 42%, 0.1) 0px, transparent 50%),
                          radial-gradient(at 20% 90%, hsla(295, 98%, 42%, 0.1) 0px, transparent 50%);
        font-family: 'Inter', sans-serif;
      }
      /* Custom scrollbar for webkit browsers */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: rgba(2, 6, 23, 0.2);
      }
      ::-webkit-scrollbar-thumb {
        background-color: #334155; /* slate-700 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background-color: #475569; /* slate-600 */
      }
      .fade-in {
        animation: fadeInAnimation 0.5s ease-in-out forwards;
      }
      @keyframes fadeInAnimation {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react-dom": "https://aistudiocdn.com/react-dom@^19.2.0"
  }
}
</script>
</head>
  <body class="text-gray-300">
    <div id="root"></div>

    <script id="worker" type="text/worker">
/**
 * @description  Thực thi các tác vụ được đăng ký, được gửi từ luồng chính.
 * @purpose      Là đơn vị thực thi độc lập, an toàn, chạy trong một luồng riêng biệt.
 * @solves       Tách biệt việc tính toán nặng ra khỏi luồng chính một cách an toàn.
 * @model        Mô hình Actor.
 * @rationale    Worker import trực tiếp registry, đảm bảo type-safety và cho phép bundler đóng gói các phụ thuộc một cách chính xác. Việc gọi hàm qua một khóa chuỗi là một cơ chế điều phối (dispatch) an toàn và hiệu quả. Bằng cách nhúng registry trực tiếp, chúng ta loại bỏ các vấn đề về tải module trong môi trường worker.
 */

// --- Registry được nhúng trực tiếp để tránh lỗi bảo mật khi import ---

/**
 * @description  Một registry tập trung cho tất cả các hàm có thể được thực thi bởi Conductor.
 * @purpose      Loại bỏ rủi ro an ninh và các vấn-đề bảo trì của việc thực thi mã động (`new Function`).
 * @solves       Cung cấp một "allow-list" các tác vụ, đảm bảo chỉ mã nguồn đã được kiểm duyệt mới có thể chạy.
 * @model        Mô hình Registry.
 * @rationale    Đây là một mẫu thiết kế bảo mật tiêu chuẩn. Bằng cách định nghĩa trước các tác vụ, chúng ta cho phép các công cụ như TypeScript và Webpack phân tích, tối ưu hóa và đóng gói mã nguồn một cách chính xác, đồng thời ngăn chặn hoàn toàn các cuộc tấn công chèn mã.
 */

// Tác vụ nặng để trình diễn xử lý song song
function heavy(chunk) {
    // Một phép tính vô nghĩa nhưng tốn thời gian
    return chunk.reduce((s, v) => s + Math.sqrt(v), 0);
}

// Tác vụ tạo dữ liệu mẫu
function generate(count) {
    const data = [];
    const start = new Date(2020, 0, 1).getTime();
    const end = new Date(2024, 11, 31).getTime();
    for (let i = 0; i < count; i++) {
        data.push({
            id: i,
            user: Math.floor(Math.random() * 100),
            product: Math.floor(Math.random() * 1000),
            amount: Math.random() * 200,
            timestamp: start + Math.random() * (end - start),
        });
    }
    return data;
}

// Tác vụ xây dựng chỉ mục Tree
function build(column) {
    // Chuyển đổi sang BigInt để sắp xếp chính xác.
    const values = Array.from(column, (v) => BigInt(String(v)));
    const indices = Array.from({ length: values.length }, (_, i) => i);
    
    indices.sort((a, b) => {
        const x = values[a];
        const y = values[b];
        if (x < y) return -1;
        if (x > y) return 1;
        return 0;
    });

    // Trả về một cấu trúc chứa cả giá trị và chỉ số đã được sắp xếp
    // để luồng chính có thể tái tạo lại chỉ mục.
    const result = indices.map(i => values[i]);
    return { values: result, indices: indices };
}


const registry = {
    heavy,
    generate,
    build,
};

// --- Kết thúc registry được nhúng ---


self.onmessage = async function(event) {
    const { name, args, id } = event.data;

    const task = registry[name];

    if (!task) {
        self.postMessage({ id, error: `Task '${name}' not found in registry.` });
        return;
    }

    try {
        const result = await task(...args);
        
        // Phản hồi có thể chứa Transferable Objects, nhưng ở đây chúng ta chỉ trả về kết quả
        self.postMessage({ id, result });

    } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        self.postMessage({ id, error: message });
    }
};
    </script>
    
    <script type="module" src="/index.tsx"></script>
  </body>
</html>